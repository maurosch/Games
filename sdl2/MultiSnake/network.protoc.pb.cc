// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: network.protoc

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "network.protoc.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace network {

namespace {

const ::google::protobuf::Descriptor* PositionSnakePart_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PositionSnakePart_reflection_ = NULL;
const ::google::protobuf::Descriptor* StrawBerry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StrawBerry_reflection_ = NULL;
const ::google::protobuf::Descriptor* Snake_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Snake_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Snake_RGBColor_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FromServerToClient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FromServerToClient_reflection_ = NULL;
const ::google::protobuf::Descriptor* FromClientToServer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FromClientToServer_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FromClientToServer_TypesOfHit_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FirstMessageFromServerToClient_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FirstMessageFromServerToClient_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FirstMessageFromServerToClient_eYouAre_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_network_2eprotoc() {
  protobuf_AddDesc_network_2eprotoc();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "network.protoc");
  GOOGLE_CHECK(file != NULL);
  PositionSnakePart_descriptor_ = file->message_type(0);
  static const int PositionSnakePart_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionSnakePart, pos_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionSnakePart, pos_y_),
  };
  PositionSnakePart_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PositionSnakePart_descriptor_,
      PositionSnakePart::default_instance_,
      PositionSnakePart_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionSnakePart, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PositionSnakePart, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PositionSnakePart));
  StrawBerry_descriptor_ = file->message_type(1);
  static const int StrawBerry_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, pos_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, pos_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, life_),
  };
  StrawBerry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StrawBerry_descriptor_,
      StrawBerry::default_instance_,
      StrawBerry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StrawBerry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StrawBerry));
  Snake_descriptor_ = file->message_type(2);
  static const int Snake_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, positionsnakepart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, life_),
  };
  Snake_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Snake_descriptor_,
      Snake::default_instance_,
      Snake_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Snake, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Snake));
  Snake_RGBColor_descriptor_ = Snake_descriptor_->enum_type(0);
  FromServerToClient_descriptor_ = file->message_type(3);
  static const int FromServerToClient_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, gameover_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, youcanaddapart_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, snakes_game_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, strawberry_),
  };
  FromServerToClient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FromServerToClient_descriptor_,
      FromServerToClient::default_instance_,
      FromServerToClient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromServerToClient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FromServerToClient));
  FromClientToServer_descriptor_ = file->message_type(4);
  static const int FromClientToServer_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromClientToServer, snakeclient_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromClientToServer, hitwith_),
  };
  FromClientToServer_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FromClientToServer_descriptor_,
      FromClientToServer::default_instance_,
      FromClientToServer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromClientToServer, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FromClientToServer, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FromClientToServer));
  FromClientToServer_TypesOfHit_descriptor_ = FromClientToServer_descriptor_->enum_type(0);
  FirstMessageFromServerToClient_descriptor_ = file->message_type(5);
  static const int FirstMessageFromServerToClient_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, walls_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, idtogive_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, you_are_),
  };
  FirstMessageFromServerToClient_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FirstMessageFromServerToClient_descriptor_,
      FirstMessageFromServerToClient::default_instance_,
      FirstMessageFromServerToClient_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FirstMessageFromServerToClient, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FirstMessageFromServerToClient));
  FirstMessageFromServerToClient_eYouAre_descriptor_ = FirstMessageFromServerToClient_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_network_2eprotoc);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PositionSnakePart_descriptor_, &PositionSnakePart::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StrawBerry_descriptor_, &StrawBerry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Snake_descriptor_, &Snake::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FromServerToClient_descriptor_, &FromServerToClient::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FromClientToServer_descriptor_, &FromClientToServer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FirstMessageFromServerToClient_descriptor_, &FirstMessageFromServerToClient::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_network_2eprotoc() {
  delete PositionSnakePart::default_instance_;
  delete PositionSnakePart_reflection_;
  delete StrawBerry::default_instance_;
  delete StrawBerry_reflection_;
  delete Snake::default_instance_;
  delete Snake_reflection_;
  delete FromServerToClient::default_instance_;
  delete FromServerToClient_reflection_;
  delete FromClientToServer::default_instance_;
  delete FromClientToServer_reflection_;
  delete FirstMessageFromServerToClient::default_instance_;
  delete FirstMessageFromServerToClient_reflection_;
}

void protobuf_AddDesc_network_2eprotoc() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016network.protoc\022\007network\"1\n\021PositionSna"
    "kePart\022\r\n\005pos_x\030\001 \002(\005\022\r\n\005pos_y\030\002 \002(\005\"D\n\n"
    "StrawBerry\022\r\n\005pos_x\030\001 \002(\005\022\r\n\005pos_y\030\002 \002(\005"
    "\022\n\n\002id\030\003 \002(\005\022\014\n\004life\030\004 \002(\010\"\343\001\n\005Snake\022\n\n\002"
    "id\030\001 \002(\005\0225\n\021positionsnakepart\030\002 \003(\0132\032.ne"
    "twork.PositionSnakePart\022&\n\005color\030\003 \002(\0162\027"
    ".network.Snake.RGBColor\022\014\n\004life\030\004 \002(\010\"a\n"
    "\010RGBColor\022\007\n\003RED\020\000\022\t\n\005GREEN\020\001\022\010\n\004BLUE\020\002\022"
    "\010\n\004GREY\020\003\022\n\n\006YELLOW\020\004\022\n\n\006ORANGE\020\005\022\n\n\006VIO"
    "LET\020\006\022\t\n\005BROWN\020\007\"\223\001\n\022FromServerToClient\022"
    "\027\n\010gameover\030\001 \002(\010:\005false\022\026\n\016youCanAddAPa"
    "rt\030\002 \002(\010\022#\n\013snakes_game\030\003 \003(\0132\016.network."
    "Snake\022\'\n\nstrawberry\030\004 \003(\0132\023.network.Stra"
    "wBerry\"\262\001\n\022FromClientToServer\022#\n\013snakecl"
    "ient\030\001 \002(\0132\016.network.Snake\0227\n\007hitwith\030\002 "
    "\002(\0162&.network.FromClientToServer.TypesOf"
    "Hit\">\n\nTypesOfHit\022\013\n\007NOTHING\020\000\022\t\n\005SNAKE\020"
    "\001\022\016\n\nSTRAWBERRY\020\002\022\010\n\004WALL\020\003\"\245\002\n\036FirstMes"
    "sageFromServerToClient\022)\n\005walls\030\001 \001(\0132\032."
    "network.PositionSnakePart\022&\n\005color\030\002 \001(\016"
    "2\027.network.Snake.RGBColor\022\020\n\010idtogive\030\003 "
    "\001(\005\022@\n\007you_are\030\004 \002(\0162/.network.FirstMess"
    "ageFromServerToClient.eYouAre\"\\\n\007eYouAre"
    "\022\024\n\020WAITING_IN_LOBBY\020\000\022\032\n\026WAITING_TO_FIN"
    "ISH_GAME\020\001\022\016\n\nSTART_GAME\020\002\022\017\n\013SERVER_FUL"
    "L\020\003", 1003);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "network.protoc", &protobuf_RegisterTypes);
  PositionSnakePart::default_instance_ = new PositionSnakePart();
  StrawBerry::default_instance_ = new StrawBerry();
  Snake::default_instance_ = new Snake();
  FromServerToClient::default_instance_ = new FromServerToClient();
  FromClientToServer::default_instance_ = new FromClientToServer();
  FirstMessageFromServerToClient::default_instance_ = new FirstMessageFromServerToClient();
  PositionSnakePart::default_instance_->InitAsDefaultInstance();
  StrawBerry::default_instance_->InitAsDefaultInstance();
  Snake::default_instance_->InitAsDefaultInstance();
  FromServerToClient::default_instance_->InitAsDefaultInstance();
  FromClientToServer::default_instance_->InitAsDefaultInstance();
  FirstMessageFromServerToClient::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_network_2eprotoc);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_network_2eprotoc {
  StaticDescriptorInitializer_network_2eprotoc() {
    protobuf_AddDesc_network_2eprotoc();
  }
} static_descriptor_initializer_network_2eprotoc_;

// ===================================================================

#ifndef _MSC_VER
const int PositionSnakePart::kPosXFieldNumber;
const int PositionSnakePart::kPosYFieldNumber;
#endif  // !_MSC_VER

PositionSnakePart::PositionSnakePart()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.PositionSnakePart)
}

void PositionSnakePart::InitAsDefaultInstance() {
}

PositionSnakePart::PositionSnakePart(const PositionSnakePart& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.PositionSnakePart)
}

void PositionSnakePart::SharedCtor() {
  _cached_size_ = 0;
  pos_x_ = 0;
  pos_y_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PositionSnakePart::~PositionSnakePart() {
  // @@protoc_insertion_point(destructor:network.PositionSnakePart)
  SharedDtor();
}

void PositionSnakePart::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PositionSnakePart::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PositionSnakePart::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PositionSnakePart_descriptor_;
}

const PositionSnakePart& PositionSnakePart::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

PositionSnakePart* PositionSnakePart::default_instance_ = NULL;

PositionSnakePart* PositionSnakePart::New() const {
  return new PositionSnakePart;
}

void PositionSnakePart::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PositionSnakePart*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(pos_x_, pos_y_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PositionSnakePart::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.PositionSnakePart)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 pos_x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pos_y;
        break;
      }

      // required int32 pos_y = 2;
      case 2: {
        if (tag == 16) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.PositionSnakePart)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.PositionSnakePart)
  return false;
#undef DO_
}

void PositionSnakePart::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.PositionSnakePart)
  // required int32 pos_x = 1;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pos_x(), output);
  }

  // required int32 pos_y = 2;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pos_y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.PositionSnakePart)
}

::google::protobuf::uint8* PositionSnakePart::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.PositionSnakePart)
  // required int32 pos_x = 1;
  if (has_pos_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->pos_x(), target);
  }

  // required int32 pos_y = 2;
  if (has_pos_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->pos_y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.PositionSnakePart)
  return target;
}

int PositionSnakePart::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 pos_x = 1;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

    // required int32 pos_y = 2;
    if (has_pos_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_y());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PositionSnakePart::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PositionSnakePart* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PositionSnakePart*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PositionSnakePart::MergeFrom(const PositionSnakePart& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PositionSnakePart::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PositionSnakePart::CopyFrom(const PositionSnakePart& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionSnakePart::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PositionSnakePart::Swap(PositionSnakePart* other) {
  if (other != this) {
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PositionSnakePart::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PositionSnakePart_descriptor_;
  metadata.reflection = PositionSnakePart_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StrawBerry::kPosXFieldNumber;
const int StrawBerry::kPosYFieldNumber;
const int StrawBerry::kIdFieldNumber;
const int StrawBerry::kLifeFieldNumber;
#endif  // !_MSC_VER

StrawBerry::StrawBerry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.StrawBerry)
}

void StrawBerry::InitAsDefaultInstance() {
}

StrawBerry::StrawBerry(const StrawBerry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.StrawBerry)
}

void StrawBerry::SharedCtor() {
  _cached_size_ = 0;
  pos_x_ = 0;
  pos_y_ = 0;
  id_ = 0;
  life_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StrawBerry::~StrawBerry() {
  // @@protoc_insertion_point(destructor:network.StrawBerry)
  SharedDtor();
}

void StrawBerry::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StrawBerry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StrawBerry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StrawBerry_descriptor_;
}

const StrawBerry& StrawBerry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

StrawBerry* StrawBerry::default_instance_ = NULL;

StrawBerry* StrawBerry::New() const {
  return new StrawBerry;
}

void StrawBerry::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<StrawBerry*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(pos_x_, life_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StrawBerry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.StrawBerry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 pos_x = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_x_)));
          set_has_pos_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pos_y;
        break;
      }

      // required int32 pos_y = 2;
      case 2: {
        if (tag == 16) {
         parse_pos_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &pos_y_)));
          set_has_pos_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_id;
        break;
      }

      // required int32 id = 3;
      case 3: {
        if (tag == 24) {
         parse_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_life;
        break;
      }

      // required bool life = 4;
      case 4: {
        if (tag == 32) {
         parse_life:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &life_)));
          set_has_life();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.StrawBerry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.StrawBerry)
  return false;
#undef DO_
}

void StrawBerry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.StrawBerry)
  // required int32 pos_x = 1;
  if (has_pos_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->pos_x(), output);
  }

  // required int32 pos_y = 2;
  if (has_pos_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->pos_y(), output);
  }

  // required int32 id = 3;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->id(), output);
  }

  // required bool life = 4;
  if (has_life()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->life(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.StrawBerry)
}

::google::protobuf::uint8* StrawBerry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.StrawBerry)
  // required int32 pos_x = 1;
  if (has_pos_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->pos_x(), target);
  }

  // required int32 pos_y = 2;
  if (has_pos_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->pos_y(), target);
  }

  // required int32 id = 3;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->id(), target);
  }

  // required bool life = 4;
  if (has_life()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->life(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.StrawBerry)
  return target;
}

int StrawBerry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 pos_x = 1;
    if (has_pos_x()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_x());
    }

    // required int32 pos_y = 2;
    if (has_pos_y()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->pos_y());
    }

    // required int32 id = 3;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required bool life = 4;
    if (has_life()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StrawBerry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StrawBerry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StrawBerry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StrawBerry::MergeFrom(const StrawBerry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pos_x()) {
      set_pos_x(from.pos_x());
    }
    if (from.has_pos_y()) {
      set_pos_y(from.pos_y());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_life()) {
      set_life(from.life());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StrawBerry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StrawBerry::CopyFrom(const StrawBerry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrawBerry::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void StrawBerry::Swap(StrawBerry* other) {
  if (other != this) {
    std::swap(pos_x_, other->pos_x_);
    std::swap(pos_y_, other->pos_y_);
    std::swap(id_, other->id_);
    std::swap(life_, other->life_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StrawBerry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StrawBerry_descriptor_;
  metadata.reflection = StrawBerry_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Snake_RGBColor_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Snake_RGBColor_descriptor_;
}
bool Snake_RGBColor_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Snake_RGBColor Snake::RED;
const Snake_RGBColor Snake::GREEN;
const Snake_RGBColor Snake::BLUE;
const Snake_RGBColor Snake::GREY;
const Snake_RGBColor Snake::YELLOW;
const Snake_RGBColor Snake::ORANGE;
const Snake_RGBColor Snake::VIOLET;
const Snake_RGBColor Snake::BROWN;
const Snake_RGBColor Snake::RGBColor_MIN;
const Snake_RGBColor Snake::RGBColor_MAX;
const int Snake::RGBColor_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Snake::kIdFieldNumber;
const int Snake::kPositionsnakepartFieldNumber;
const int Snake::kColorFieldNumber;
const int Snake::kLifeFieldNumber;
#endif  // !_MSC_VER

Snake::Snake()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.Snake)
}

void Snake::InitAsDefaultInstance() {
}

Snake::Snake(const Snake& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.Snake)
}

void Snake::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  color_ = 0;
  life_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Snake::~Snake() {
  // @@protoc_insertion_point(destructor:network.Snake)
  SharedDtor();
}

void Snake::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Snake::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Snake::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Snake_descriptor_;
}

const Snake& Snake::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

Snake* Snake::default_instance_ = NULL;

Snake* Snake::New() const {
  return new Snake;
}

void Snake::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Snake*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(id_, life_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  positionsnakepart_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Snake::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.Snake)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_positionsnakepart;
        break;
      }

      // repeated .network.PositionSnakePart positionsnakepart = 2;
      case 2: {
        if (tag == 18) {
         parse_positionsnakepart:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_positionsnakepart()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_positionsnakepart;
        if (input->ExpectTag(24)) goto parse_color;
        break;
      }

      // required .network.Snake.RGBColor color = 3;
      case 3: {
        if (tag == 24) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::network::Snake_RGBColor_IsValid(value)) {
            set_color(static_cast< ::network::Snake_RGBColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_life;
        break;
      }

      // required bool life = 4;
      case 4: {
        if (tag == 32) {
         parse_life:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &life_)));
          set_has_life();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.Snake)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.Snake)
  return false;
#undef DO_
}

void Snake::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.Snake)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // repeated .network.PositionSnakePart positionsnakepart = 2;
  for (int i = 0; i < this->positionsnakepart_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->positionsnakepart(i), output);
  }

  // required .network.Snake.RGBColor color = 3;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->color(), output);
  }

  // required bool life = 4;
  if (has_life()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->life(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.Snake)
}

::google::protobuf::uint8* Snake::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.Snake)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // repeated .network.PositionSnakePart positionsnakepart = 2;
  for (int i = 0; i < this->positionsnakepart_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->positionsnakepart(i), target);
  }

  // required .network.Snake.RGBColor color = 3;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->color(), target);
  }

  // required bool life = 4;
  if (has_life()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->life(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.Snake)
  return target;
}

int Snake::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // required .network.Snake.RGBColor color = 3;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

    // required bool life = 4;
    if (has_life()) {
      total_size += 1 + 1;
    }

  }
  // repeated .network.PositionSnakePart positionsnakepart = 2;
  total_size += 1 * this->positionsnakepart_size();
  for (int i = 0; i < this->positionsnakepart_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->positionsnakepart(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Snake::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Snake* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Snake*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Snake::MergeFrom(const Snake& from) {
  GOOGLE_CHECK_NE(&from, this);
  positionsnakepart_.MergeFrom(from.positionsnakepart_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_life()) {
      set_life(from.life());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Snake::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Snake::CopyFrom(const Snake& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Snake::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->positionsnakepart())) return false;
  return true;
}

void Snake::Swap(Snake* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    positionsnakepart_.Swap(&other->positionsnakepart_);
    std::swap(color_, other->color_);
    std::swap(life_, other->life_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Snake::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Snake_descriptor_;
  metadata.reflection = Snake_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FromServerToClient::kGameoverFieldNumber;
const int FromServerToClient::kYouCanAddAPartFieldNumber;
const int FromServerToClient::kSnakesGameFieldNumber;
const int FromServerToClient::kStrawberryFieldNumber;
#endif  // !_MSC_VER

FromServerToClient::FromServerToClient()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FromServerToClient)
}

void FromServerToClient::InitAsDefaultInstance() {
}

FromServerToClient::FromServerToClient(const FromServerToClient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.FromServerToClient)
}

void FromServerToClient::SharedCtor() {
  _cached_size_ = 0;
  gameover_ = false;
  youcanaddapart_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FromServerToClient::~FromServerToClient() {
  // @@protoc_insertion_point(destructor:network.FromServerToClient)
  SharedDtor();
}

void FromServerToClient::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FromServerToClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FromServerToClient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FromServerToClient_descriptor_;
}

const FromServerToClient& FromServerToClient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

FromServerToClient* FromServerToClient::default_instance_ = NULL;

FromServerToClient* FromServerToClient::New() const {
  return new FromServerToClient;
}

void FromServerToClient::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FromServerToClient*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(gameover_, youcanaddapart_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  snakes_game_.Clear();
  strawberry_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FromServerToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.FromServerToClient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool gameover = 1 [default = false];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &gameover_)));
          set_has_gameover();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_youCanAddAPart;
        break;
      }

      // required bool youCanAddAPart = 2;
      case 2: {
        if (tag == 16) {
         parse_youCanAddAPart:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &youcanaddapart_)));
          set_has_youcanaddapart();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_snakes_game;
        break;
      }

      // repeated .network.Snake snakes_game = 3;
      case 3: {
        if (tag == 26) {
         parse_snakes_game:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_snakes_game()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_snakes_game;
        if (input->ExpectTag(34)) goto parse_strawberry;
        break;
      }

      // repeated .network.StrawBerry strawberry = 4;
      case 4: {
        if (tag == 34) {
         parse_strawberry:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_strawberry()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_strawberry;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.FromServerToClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.FromServerToClient)
  return false;
#undef DO_
}

void FromServerToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.FromServerToClient)
  // required bool gameover = 1 [default = false];
  if (has_gameover()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->gameover(), output);
  }

  // required bool youCanAddAPart = 2;
  if (has_youcanaddapart()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->youcanaddapart(), output);
  }

  // repeated .network.Snake snakes_game = 3;
  for (int i = 0; i < this->snakes_game_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->snakes_game(i), output);
  }

  // repeated .network.StrawBerry strawberry = 4;
  for (int i = 0; i < this->strawberry_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->strawberry(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.FromServerToClient)
}

::google::protobuf::uint8* FromServerToClient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FromServerToClient)
  // required bool gameover = 1 [default = false];
  if (has_gameover()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->gameover(), target);
  }

  // required bool youCanAddAPart = 2;
  if (has_youcanaddapart()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->youcanaddapart(), target);
  }

  // repeated .network.Snake snakes_game = 3;
  for (int i = 0; i < this->snakes_game_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->snakes_game(i), target);
  }

  // repeated .network.StrawBerry strawberry = 4;
  for (int i = 0; i < this->strawberry_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->strawberry(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FromServerToClient)
  return target;
}

int FromServerToClient::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool gameover = 1 [default = false];
    if (has_gameover()) {
      total_size += 1 + 1;
    }

    // required bool youCanAddAPart = 2;
    if (has_youcanaddapart()) {
      total_size += 1 + 1;
    }

  }
  // repeated .network.Snake snakes_game = 3;
  total_size += 1 * this->snakes_game_size();
  for (int i = 0; i < this->snakes_game_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->snakes_game(i));
  }

  // repeated .network.StrawBerry strawberry = 4;
  total_size += 1 * this->strawberry_size();
  for (int i = 0; i < this->strawberry_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->strawberry(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FromServerToClient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FromServerToClient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FromServerToClient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FromServerToClient::MergeFrom(const FromServerToClient& from) {
  GOOGLE_CHECK_NE(&from, this);
  snakes_game_.MergeFrom(from.snakes_game_);
  strawberry_.MergeFrom(from.strawberry_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gameover()) {
      set_gameover(from.gameover());
    }
    if (from.has_youcanaddapart()) {
      set_youcanaddapart(from.youcanaddapart());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FromServerToClient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FromServerToClient::CopyFrom(const FromServerToClient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FromServerToClient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->snakes_game())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->strawberry())) return false;
  return true;
}

void FromServerToClient::Swap(FromServerToClient* other) {
  if (other != this) {
    std::swap(gameover_, other->gameover_);
    std::swap(youcanaddapart_, other->youcanaddapart_);
    snakes_game_.Swap(&other->snakes_game_);
    strawberry_.Swap(&other->strawberry_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FromServerToClient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FromServerToClient_descriptor_;
  metadata.reflection = FromServerToClient_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FromClientToServer_TypesOfHit_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FromClientToServer_TypesOfHit_descriptor_;
}
bool FromClientToServer_TypesOfHit_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FromClientToServer_TypesOfHit FromClientToServer::NOTHING;
const FromClientToServer_TypesOfHit FromClientToServer::SNAKE;
const FromClientToServer_TypesOfHit FromClientToServer::STRAWBERRY;
const FromClientToServer_TypesOfHit FromClientToServer::WALL;
const FromClientToServer_TypesOfHit FromClientToServer::TypesOfHit_MIN;
const FromClientToServer_TypesOfHit FromClientToServer::TypesOfHit_MAX;
const int FromClientToServer::TypesOfHit_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FromClientToServer::kSnakeclientFieldNumber;
const int FromClientToServer::kHitwithFieldNumber;
#endif  // !_MSC_VER

FromClientToServer::FromClientToServer()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FromClientToServer)
}

void FromClientToServer::InitAsDefaultInstance() {
  snakeclient_ = const_cast< ::network::Snake*>(&::network::Snake::default_instance());
}

FromClientToServer::FromClientToServer(const FromClientToServer& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.FromClientToServer)
}

void FromClientToServer::SharedCtor() {
  _cached_size_ = 0;
  snakeclient_ = NULL;
  hitwith_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FromClientToServer::~FromClientToServer() {
  // @@protoc_insertion_point(destructor:network.FromClientToServer)
  SharedDtor();
}

void FromClientToServer::SharedDtor() {
  if (this != default_instance_) {
    delete snakeclient_;
  }
}

void FromClientToServer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FromClientToServer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FromClientToServer_descriptor_;
}

const FromClientToServer& FromClientToServer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

FromClientToServer* FromClientToServer::default_instance_ = NULL;

FromClientToServer* FromClientToServer::New() const {
  return new FromClientToServer;
}

void FromClientToServer::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_snakeclient()) {
      if (snakeclient_ != NULL) snakeclient_->::network::Snake::Clear();
    }
    hitwith_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FromClientToServer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.FromClientToServer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .network.Snake snakeclient = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_snakeclient()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_hitwith;
        break;
      }

      // required .network.FromClientToServer.TypesOfHit hitwith = 2;
      case 2: {
        if (tag == 16) {
         parse_hitwith:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::network::FromClientToServer_TypesOfHit_IsValid(value)) {
            set_hitwith(static_cast< ::network::FromClientToServer_TypesOfHit >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.FromClientToServer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.FromClientToServer)
  return false;
#undef DO_
}

void FromClientToServer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.FromClientToServer)
  // required .network.Snake snakeclient = 1;
  if (has_snakeclient()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->snakeclient(), output);
  }

  // required .network.FromClientToServer.TypesOfHit hitwith = 2;
  if (has_hitwith()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->hitwith(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.FromClientToServer)
}

::google::protobuf::uint8* FromClientToServer::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FromClientToServer)
  // required .network.Snake snakeclient = 1;
  if (has_snakeclient()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->snakeclient(), target);
  }

  // required .network.FromClientToServer.TypesOfHit hitwith = 2;
  if (has_hitwith()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->hitwith(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FromClientToServer)
  return target;
}

int FromClientToServer::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .network.Snake snakeclient = 1;
    if (has_snakeclient()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->snakeclient());
    }

    // required .network.FromClientToServer.TypesOfHit hitwith = 2;
    if (has_hitwith()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->hitwith());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FromClientToServer::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FromClientToServer* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FromClientToServer*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FromClientToServer::MergeFrom(const FromClientToServer& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_snakeclient()) {
      mutable_snakeclient()->::network::Snake::MergeFrom(from.snakeclient());
    }
    if (from.has_hitwith()) {
      set_hitwith(from.hitwith());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FromClientToServer::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FromClientToServer::CopyFrom(const FromClientToServer& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FromClientToServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_snakeclient()) {
    if (!this->snakeclient().IsInitialized()) return false;
  }
  return true;
}

void FromClientToServer::Swap(FromClientToServer* other) {
  if (other != this) {
    std::swap(snakeclient_, other->snakeclient_);
    std::swap(hitwith_, other->hitwith_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FromClientToServer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FromClientToServer_descriptor_;
  metadata.reflection = FromClientToServer_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FirstMessageFromServerToClient_eYouAre_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstMessageFromServerToClient_eYouAre_descriptor_;
}
bool FirstMessageFromServerToClient_eYouAre_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::WAITING_IN_LOBBY;
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::WAITING_TO_FINISH_GAME;
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::START_GAME;
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::SERVER_FULL;
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::eYouAre_MIN;
const FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::eYouAre_MAX;
const int FirstMessageFromServerToClient::eYouAre_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FirstMessageFromServerToClient::kWallsFieldNumber;
const int FirstMessageFromServerToClient::kColorFieldNumber;
const int FirstMessageFromServerToClient::kIdtogiveFieldNumber;
const int FirstMessageFromServerToClient::kYouAreFieldNumber;
#endif  // !_MSC_VER

FirstMessageFromServerToClient::FirstMessageFromServerToClient()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FirstMessageFromServerToClient)
}

void FirstMessageFromServerToClient::InitAsDefaultInstance() {
  walls_ = const_cast< ::network::PositionSnakePart*>(&::network::PositionSnakePart::default_instance());
}

FirstMessageFromServerToClient::FirstMessageFromServerToClient(const FirstMessageFromServerToClient& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:network.FirstMessageFromServerToClient)
}

void FirstMessageFromServerToClient::SharedCtor() {
  _cached_size_ = 0;
  walls_ = NULL;
  color_ = 0;
  idtogive_ = 0;
  you_are_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FirstMessageFromServerToClient::~FirstMessageFromServerToClient() {
  // @@protoc_insertion_point(destructor:network.FirstMessageFromServerToClient)
  SharedDtor();
}

void FirstMessageFromServerToClient::SharedDtor() {
  if (this != default_instance_) {
    delete walls_;
  }
}

void FirstMessageFromServerToClient::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FirstMessageFromServerToClient::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FirstMessageFromServerToClient_descriptor_;
}

const FirstMessageFromServerToClient& FirstMessageFromServerToClient::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_network_2eprotoc();
  return *default_instance_;
}

FirstMessageFromServerToClient* FirstMessageFromServerToClient::default_instance_ = NULL;

FirstMessageFromServerToClient* FirstMessageFromServerToClient::New() const {
  return new FirstMessageFromServerToClient;
}

void FirstMessageFromServerToClient::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FirstMessageFromServerToClient*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(color_, you_are_);
    if (has_walls()) {
      if (walls_ != NULL) walls_->::network::PositionSnakePart::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FirstMessageFromServerToClient::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:network.FirstMessageFromServerToClient)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .network.PositionSnakePart walls = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_walls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_color;
        break;
      }

      // optional .network.Snake.RGBColor color = 2;
      case 2: {
        if (tag == 16) {
         parse_color:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::network::Snake_RGBColor_IsValid(value)) {
            set_color(static_cast< ::network::Snake_RGBColor >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_idtogive;
        break;
      }

      // optional int32 idtogive = 3;
      case 3: {
        if (tag == 24) {
         parse_idtogive:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &idtogive_)));
          set_has_idtogive();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_you_are;
        break;
      }

      // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
      case 4: {
        if (tag == 32) {
         parse_you_are:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::network::FirstMessageFromServerToClient_eYouAre_IsValid(value)) {
            set_you_are(static_cast< ::network::FirstMessageFromServerToClient_eYouAre >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:network.FirstMessageFromServerToClient)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:network.FirstMessageFromServerToClient)
  return false;
#undef DO_
}

void FirstMessageFromServerToClient::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:network.FirstMessageFromServerToClient)
  // optional .network.PositionSnakePart walls = 1;
  if (has_walls()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->walls(), output);
  }

  // optional .network.Snake.RGBColor color = 2;
  if (has_color()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->color(), output);
  }

  // optional int32 idtogive = 3;
  if (has_idtogive()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->idtogive(), output);
  }

  // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
  if (has_you_are()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->you_are(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:network.FirstMessageFromServerToClient)
}

::google::protobuf::uint8* FirstMessageFromServerToClient::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FirstMessageFromServerToClient)
  // optional .network.PositionSnakePart walls = 1;
  if (has_walls()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->walls(), target);
  }

  // optional .network.Snake.RGBColor color = 2;
  if (has_color()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->color(), target);
  }

  // optional int32 idtogive = 3;
  if (has_idtogive()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->idtogive(), target);
  }

  // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
  if (has_you_are()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->you_are(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FirstMessageFromServerToClient)
  return target;
}

int FirstMessageFromServerToClient::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .network.PositionSnakePart walls = 1;
    if (has_walls()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->walls());
    }

    // optional .network.Snake.RGBColor color = 2;
    if (has_color()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->color());
    }

    // optional int32 idtogive = 3;
    if (has_idtogive()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->idtogive());
    }

    // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
    if (has_you_are()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->you_are());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FirstMessageFromServerToClient::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FirstMessageFromServerToClient* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FirstMessageFromServerToClient*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FirstMessageFromServerToClient::MergeFrom(const FirstMessageFromServerToClient& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_walls()) {
      mutable_walls()->::network::PositionSnakePart::MergeFrom(from.walls());
    }
    if (from.has_color()) {
      set_color(from.color());
    }
    if (from.has_idtogive()) {
      set_idtogive(from.idtogive());
    }
    if (from.has_you_are()) {
      set_you_are(from.you_are());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FirstMessageFromServerToClient::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstMessageFromServerToClient::CopyFrom(const FirstMessageFromServerToClient& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstMessageFromServerToClient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000008) != 0x00000008) return false;

  if (has_walls()) {
    if (!this->walls().IsInitialized()) return false;
  }
  return true;
}

void FirstMessageFromServerToClient::Swap(FirstMessageFromServerToClient* other) {
  if (other != this) {
    std::swap(walls_, other->walls_);
    std::swap(color_, other->color_);
    std::swap(idtogive_, other->idtogive_);
    std::swap(you_are_, other->you_are_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FirstMessageFromServerToClient::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FirstMessageFromServerToClient_descriptor_;
  metadata.reflection = FirstMessageFromServerToClient_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace network

// @@protoc_insertion_point(global_scope)
