// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: network.protoc

#include "network.protoc.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_network_2eprotoc ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PositionSnakePart_network_2eprotoc;
extern PROTOBUF_INTERNAL_EXPORT_network_2eprotoc ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Snake_network_2eprotoc;
extern PROTOBUF_INTERNAL_EXPORT_network_2eprotoc ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StrawBerry_network_2eprotoc;
namespace network {
class PositionSnakePartDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PositionSnakePart> _instance;
} _PositionSnakePart_default_instance_;
class StrawBerryDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StrawBerry> _instance;
} _StrawBerry_default_instance_;
class SnakeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Snake> _instance;
} _Snake_default_instance_;
class FromServerToClientDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FromServerToClient> _instance;
} _FromServerToClient_default_instance_;
class FromClientToServerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FromClientToServer> _instance;
} _FromClientToServer_default_instance_;
class FirstMessageFromServerToClientDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FirstMessageFromServerToClient> _instance;
} _FirstMessageFromServerToClient_default_instance_;
}  // namespace network
static void InitDefaultsscc_info_FirstMessageFromServerToClient_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_FirstMessageFromServerToClient_default_instance_;
    new (ptr) ::network::FirstMessageFromServerToClient();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::FirstMessageFromServerToClient::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FirstMessageFromServerToClient_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FirstMessageFromServerToClient_network_2eprotoc}, {
      &scc_info_PositionSnakePart_network_2eprotoc.base,}};

static void InitDefaultsscc_info_FromClientToServer_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_FromClientToServer_default_instance_;
    new (ptr) ::network::FromClientToServer();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::FromClientToServer::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FromClientToServer_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FromClientToServer_network_2eprotoc}, {
      &scc_info_Snake_network_2eprotoc.base,}};

static void InitDefaultsscc_info_FromServerToClient_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_FromServerToClient_default_instance_;
    new (ptr) ::network::FromServerToClient();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::FromServerToClient::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_FromServerToClient_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_FromServerToClient_network_2eprotoc}, {
      &scc_info_Snake_network_2eprotoc.base,
      &scc_info_StrawBerry_network_2eprotoc.base,}};

static void InitDefaultsscc_info_PositionSnakePart_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_PositionSnakePart_default_instance_;
    new (ptr) ::network::PositionSnakePart();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::PositionSnakePart::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PositionSnakePart_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PositionSnakePart_network_2eprotoc}, {}};

static void InitDefaultsscc_info_Snake_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_Snake_default_instance_;
    new (ptr) ::network::Snake();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::Snake::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Snake_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Snake_network_2eprotoc}, {
      &scc_info_PositionSnakePart_network_2eprotoc.base,}};

static void InitDefaultsscc_info_StrawBerry_network_2eprotoc() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::network::_StrawBerry_default_instance_;
    new (ptr) ::network::StrawBerry();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::network::StrawBerry::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StrawBerry_network_2eprotoc =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StrawBerry_network_2eprotoc}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_network_2eprotoc[6];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_network_2eprotoc[3];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_network_2eprotoc = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_network_2eprotoc::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::network::PositionSnakePart, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::PositionSnakePart, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::PositionSnakePart, pos_x_),
  PROTOBUF_FIELD_OFFSET(::network::PositionSnakePart, pos_y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, pos_x_),
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, pos_y_),
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, id_),
  PROTOBUF_FIELD_OFFSET(::network::StrawBerry, life_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::network::Snake, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::Snake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::Snake, id_),
  PROTOBUF_FIELD_OFFSET(::network::Snake, positionsnakepart_),
  PROTOBUF_FIELD_OFFSET(::network::Snake, color_),
  PROTOBUF_FIELD_OFFSET(::network::Snake, life_),
  0,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, gameover_),
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, youcanaddapart_),
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, snakes_game_),
  PROTOBUF_FIELD_OFFSET(::network::FromServerToClient, strawberry_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::network::FromClientToServer, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::FromClientToServer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::FromClientToServer, snakeclient_),
  PROTOBUF_FIELD_OFFSET(::network::FromClientToServer, hitwith_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, walls_),
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, color_),
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, idtogive_),
  PROTOBUF_FIELD_OFFSET(::network::FirstMessageFromServerToClient, you_are_),
  0,
  1,
  2,
  3,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::network::PositionSnakePart)},
  { 9, 18, sizeof(::network::StrawBerry)},
  { 22, 31, sizeof(::network::Snake)},
  { 35, 44, sizeof(::network::FromServerToClient)},
  { 48, 55, sizeof(::network::FromClientToServer)},
  { 57, 66, sizeof(::network::FirstMessageFromServerToClient)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_PositionSnakePart_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_StrawBerry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_Snake_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_FromServerToClient_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_FromClientToServer_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::network::_FirstMessageFromServerToClient_default_instance_),
};

const char descriptor_table_protodef_network_2eprotoc[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016network.protoc\022\007network\"1\n\021PositionSna"
  "kePart\022\r\n\005pos_x\030\001 \002(\005\022\r\n\005pos_y\030\002 \002(\005\"D\n\n"
  "StrawBerry\022\r\n\005pos_x\030\001 \002(\005\022\r\n\005pos_y\030\002 \002(\005"
  "\022\n\n\002id\030\003 \002(\005\022\014\n\004life\030\004 \002(\010\"\343\001\n\005Snake\022\n\n\002"
  "id\030\001 \002(\005\0225\n\021positionsnakepart\030\002 \003(\0132\032.ne"
  "twork.PositionSnakePart\022&\n\005color\030\003 \002(\0162\027"
  ".network.Snake.RGBColor\022\014\n\004life\030\004 \002(\010\"a\n"
  "\010RGBColor\022\007\n\003RED\020\000\022\t\n\005GREEN\020\001\022\010\n\004BLUE\020\002\022"
  "\010\n\004GREY\020\003\022\n\n\006YELLOW\020\004\022\n\n\006ORANGE\020\005\022\n\n\006VIO"
  "LET\020\006\022\t\n\005BROWN\020\007\"\223\001\n\022FromServerToClient\022"
  "\027\n\010gameover\030\001 \002(\010:\005false\022\026\n\016youCanAddAPa"
  "rt\030\002 \002(\010\022#\n\013snakes_game\030\003 \003(\0132\016.network."
  "Snake\022\'\n\nstrawberry\030\004 \003(\0132\023.network.Stra"
  "wBerry\"\262\001\n\022FromClientToServer\022#\n\013snakecl"
  "ient\030\001 \002(\0132\016.network.Snake\0227\n\007hitwith\030\002 "
  "\002(\0162&.network.FromClientToServer.TypesOf"
  "Hit\">\n\nTypesOfHit\022\013\n\007NOTHING\020\000\022\t\n\005SNAKE\020"
  "\001\022\016\n\nSTRAWBERRY\020\002\022\010\n\004WALL\020\003\"\245\002\n\036FirstMes"
  "sageFromServerToClient\022)\n\005walls\030\001 \001(\0132\032."
  "network.PositionSnakePart\022&\n\005color\030\002 \001(\016"
  "2\027.network.Snake.RGBColor\022\020\n\010idtogive\030\003 "
  "\001(\005\022@\n\007you_are\030\004 \002(\0162/.network.FirstMess"
  "ageFromServerToClient.eYouAre\"\\\n\007eYouAre"
  "\022\024\n\020WAITING_IN_LOBBY\020\000\022\032\n\026WAITING_TO_FIN"
  "ISH_GAME\020\001\022\016\n\nSTART_GAME\020\002\022\017\n\013SERVER_FUL"
  "L\020\003"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_network_2eprotoc_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_network_2eprotoc_sccs[6] = {
  &scc_info_FirstMessageFromServerToClient_network_2eprotoc.base,
  &scc_info_FromClientToServer_network_2eprotoc.base,
  &scc_info_FromServerToClient_network_2eprotoc.base,
  &scc_info_PositionSnakePart_network_2eprotoc.base,
  &scc_info_Snake_network_2eprotoc.base,
  &scc_info_StrawBerry_network_2eprotoc.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_network_2eprotoc_once;
static bool descriptor_table_network_2eprotoc_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_network_2eprotoc = {
  &descriptor_table_network_2eprotoc_initialized, descriptor_table_protodef_network_2eprotoc, "network.protoc", 1003,
  &descriptor_table_network_2eprotoc_once, descriptor_table_network_2eprotoc_sccs, descriptor_table_network_2eprotoc_deps, 6, 0,
  schemas, file_default_instances, TableStruct_network_2eprotoc::offsets,
  file_level_metadata_network_2eprotoc, 6, file_level_enum_descriptors_network_2eprotoc, file_level_service_descriptors_network_2eprotoc,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_network_2eprotoc = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_network_2eprotoc), true);
namespace network {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Snake_RGBColor_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_network_2eprotoc);
  return file_level_enum_descriptors_network_2eprotoc[0];
}
bool Snake_RGBColor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Snake_RGBColor Snake::RED;
constexpr Snake_RGBColor Snake::GREEN;
constexpr Snake_RGBColor Snake::BLUE;
constexpr Snake_RGBColor Snake::GREY;
constexpr Snake_RGBColor Snake::YELLOW;
constexpr Snake_RGBColor Snake::ORANGE;
constexpr Snake_RGBColor Snake::VIOLET;
constexpr Snake_RGBColor Snake::BROWN;
constexpr Snake_RGBColor Snake::RGBColor_MIN;
constexpr Snake_RGBColor Snake::RGBColor_MAX;
constexpr int Snake::RGBColor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FromClientToServer_TypesOfHit_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_network_2eprotoc);
  return file_level_enum_descriptors_network_2eprotoc[1];
}
bool FromClientToServer_TypesOfHit_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FromClientToServer_TypesOfHit FromClientToServer::NOTHING;
constexpr FromClientToServer_TypesOfHit FromClientToServer::SNAKE;
constexpr FromClientToServer_TypesOfHit FromClientToServer::STRAWBERRY;
constexpr FromClientToServer_TypesOfHit FromClientToServer::WALL;
constexpr FromClientToServer_TypesOfHit FromClientToServer::TypesOfHit_MIN;
constexpr FromClientToServer_TypesOfHit FromClientToServer::TypesOfHit_MAX;
constexpr int FromClientToServer::TypesOfHit_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FirstMessageFromServerToClient_eYouAre_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_network_2eprotoc);
  return file_level_enum_descriptors_network_2eprotoc[2];
}
bool FirstMessageFromServerToClient_eYouAre_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::WAITING_IN_LOBBY;
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::WAITING_TO_FINISH_GAME;
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::START_GAME;
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::SERVER_FULL;
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::eYouAre_MIN;
constexpr FirstMessageFromServerToClient_eYouAre FirstMessageFromServerToClient::eYouAre_MAX;
constexpr int FirstMessageFromServerToClient::eYouAre_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void PositionSnakePart::InitAsDefaultInstance() {
}
class PositionSnakePart::_Internal {
 public:
  using HasBits = decltype(std::declval<PositionSnakePart>()._has_bits_);
  static void set_has_pos_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pos_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PositionSnakePart::PositionSnakePart()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.PositionSnakePart)
}
PositionSnakePart::PositionSnakePart(const PositionSnakePart& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&pos_x_, &from.pos_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&pos_y_) -
    reinterpret_cast<char*>(&pos_x_)) + sizeof(pos_y_));
  // @@protoc_insertion_point(copy_constructor:network.PositionSnakePart)
}

void PositionSnakePart::SharedCtor() {
  ::memset(&pos_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&pos_y_) -
      reinterpret_cast<char*>(&pos_x_)) + sizeof(pos_y_));
}

PositionSnakePart::~PositionSnakePart() {
  // @@protoc_insertion_point(destructor:network.PositionSnakePart)
  SharedDtor();
}

void PositionSnakePart::SharedDtor() {
}

void PositionSnakePart::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PositionSnakePart& PositionSnakePart::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PositionSnakePart_network_2eprotoc.base);
  return *internal_default_instance();
}


void PositionSnakePart::Clear() {
// @@protoc_insertion_point(message_clear_start:network.PositionSnakePart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&pos_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&pos_y_) -
        reinterpret_cast<char*>(&pos_x_)) + sizeof(pos_y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* PositionSnakePart::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 pos_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_pos_x(&has_bits);
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 pos_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pos_y(&has_bits);
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PositionSnakePart::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.PositionSnakePart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 pos_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_pos_x(), target);
  }

  // required int32 pos_y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_pos_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.PositionSnakePart)
  return target;
}

size_t PositionSnakePart::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:network.PositionSnakePart)
  size_t total_size = 0;

  if (_internal_has_pos_x()) {
    // required int32 pos_x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_x());
  }

  if (_internal_has_pos_y()) {
    // required int32 pos_y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_y());
  }

  return total_size;
}
size_t PositionSnakePart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.PositionSnakePart)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 pos_x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_x());

    // required int32 pos_y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_y());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PositionSnakePart::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.PositionSnakePart)
  GOOGLE_DCHECK_NE(&from, this);
  const PositionSnakePart* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PositionSnakePart>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.PositionSnakePart)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.PositionSnakePart)
    MergeFrom(*source);
  }
}

void PositionSnakePart::MergeFrom(const PositionSnakePart& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.PositionSnakePart)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      pos_x_ = from.pos_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      pos_y_ = from.pos_y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PositionSnakePart::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.PositionSnakePart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PositionSnakePart::CopyFrom(const PositionSnakePart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.PositionSnakePart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PositionSnakePart::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void PositionSnakePart::InternalSwap(PositionSnakePart* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_x_, other->pos_x_);
  swap(pos_y_, other->pos_y_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PositionSnakePart::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StrawBerry::InitAsDefaultInstance() {
}
class StrawBerry::_Internal {
 public:
  using HasBits = decltype(std::declval<StrawBerry>()._has_bits_);
  static void set_has_pos_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pos_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StrawBerry::StrawBerry()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.StrawBerry)
}
StrawBerry::StrawBerry(const StrawBerry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&pos_x_, &from.pos_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&life_) -
    reinterpret_cast<char*>(&pos_x_)) + sizeof(life_));
  // @@protoc_insertion_point(copy_constructor:network.StrawBerry)
}

void StrawBerry::SharedCtor() {
  ::memset(&pos_x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&life_) -
      reinterpret_cast<char*>(&pos_x_)) + sizeof(life_));
}

StrawBerry::~StrawBerry() {
  // @@protoc_insertion_point(destructor:network.StrawBerry)
  SharedDtor();
}

void StrawBerry::SharedDtor() {
}

void StrawBerry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StrawBerry& StrawBerry::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StrawBerry_network_2eprotoc.base);
  return *internal_default_instance();
}


void StrawBerry::Clear() {
// @@protoc_insertion_point(message_clear_start:network.StrawBerry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&pos_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&life_) -
        reinterpret_cast<char*>(&pos_x_)) + sizeof(life_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* StrawBerry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 pos_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_pos_x(&has_bits);
          pos_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 pos_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_pos_y(&has_bits);
          pos_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool life = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_life(&has_bits);
          life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StrawBerry::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.StrawBerry)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 pos_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_pos_x(), target);
  }

  // required int32 pos_y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_pos_y(), target);
  }

  // required int32 id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_id(), target);
  }

  // required bool life = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_life(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.StrawBerry)
  return target;
}

size_t StrawBerry::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:network.StrawBerry)
  size_t total_size = 0;

  if (_internal_has_pos_x()) {
    // required int32 pos_x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_x());
  }

  if (_internal_has_pos_y()) {
    // required int32 pos_y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_y());
  }

  if (_internal_has_id()) {
    // required int32 id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  if (_internal_has_life()) {
    // required bool life = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t StrawBerry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.StrawBerry)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required int32 pos_x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_x());

    // required int32 pos_y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_pos_y());

    // required int32 id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());

    // required bool life = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StrawBerry::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.StrawBerry)
  GOOGLE_DCHECK_NE(&from, this);
  const StrawBerry* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StrawBerry>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.StrawBerry)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.StrawBerry)
    MergeFrom(*source);
  }
}

void StrawBerry::MergeFrom(const StrawBerry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.StrawBerry)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      pos_x_ = from.pos_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      pos_y_ = from.pos_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      life_ = from.life_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StrawBerry::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.StrawBerry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StrawBerry::CopyFrom(const StrawBerry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.StrawBerry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrawBerry::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  return true;
}

void StrawBerry::InternalSwap(StrawBerry* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pos_x_, other->pos_x_);
  swap(pos_y_, other->pos_y_);
  swap(id_, other->id_);
  swap(life_, other->life_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StrawBerry::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Snake::InitAsDefaultInstance() {
}
class Snake::_Internal {
 public:
  using HasBits = decltype(std::declval<Snake>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

Snake::Snake()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.Snake)
}
Snake::Snake(const Snake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      positionsnakepart_(from.positionsnakepart_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&life_) -
    reinterpret_cast<char*>(&id_)) + sizeof(life_));
  // @@protoc_insertion_point(copy_constructor:network.Snake)
}

void Snake::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Snake_network_2eprotoc.base);
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&life_) -
      reinterpret_cast<char*>(&id_)) + sizeof(life_));
}

Snake::~Snake() {
  // @@protoc_insertion_point(destructor:network.Snake)
  SharedDtor();
}

void Snake::SharedDtor() {
}

void Snake::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Snake& Snake::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Snake_network_2eprotoc.base);
  return *internal_default_instance();
}


void Snake::Clear() {
// @@protoc_insertion_point(message_clear_start:network.Snake)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  positionsnakepart_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&life_) -
        reinterpret_cast<char*>(&id_)) + sizeof(life_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* Snake::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .network.PositionSnakePart positionsnakepart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_positionsnakepart(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // required .network.Snake.RGBColor color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::network::Snake_RGBColor_IsValid(val))) {
            _internal_set_color(static_cast<::network::Snake_RGBColor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bool life = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_life(&has_bits);
          life_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Snake::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.Snake)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // repeated .network.PositionSnakePart positionsnakepart = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_positionsnakepart_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_positionsnakepart(i), target, stream);
  }

  // required .network.Snake.RGBColor color = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_color(), target);
  }

  // required bool life = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_life(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.Snake)
  return target;
}

size_t Snake::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:network.Snake)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  if (_internal_has_color()) {
    // required .network.Snake.RGBColor color = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_color());
  }

  if (_internal_has_life()) {
    // required bool life = 4;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t Snake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.Snake)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());

    // required .network.Snake.RGBColor color = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_color());

    // required bool life = 4;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .network.PositionSnakePart positionsnakepart = 2;
  total_size += 1UL * this->_internal_positionsnakepart_size();
  for (const auto& msg : this->positionsnakepart_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Snake::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.Snake)
  GOOGLE_DCHECK_NE(&from, this);
  const Snake* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Snake>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.Snake)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.Snake)
    MergeFrom(*source);
  }
}

void Snake::MergeFrom(const Snake& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.Snake)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  positionsnakepart_.MergeFrom(from.positionsnakepart_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000004u) {
      life_ = from.life_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Snake::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.Snake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Snake::CopyFrom(const Snake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.Snake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Snake::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(positionsnakepart_)) return false;
  return true;
}

void Snake::InternalSwap(Snake* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  positionsnakepart_.InternalSwap(&other->positionsnakepart_);
  swap(id_, other->id_);
  swap(color_, other->color_);
  swap(life_, other->life_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Snake::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FromServerToClient::InitAsDefaultInstance() {
}
class FromServerToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<FromServerToClient>()._has_bits_);
  static void set_has_gameover(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_youcanaddapart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FromServerToClient::FromServerToClient()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FromServerToClient)
}
FromServerToClient::FromServerToClient(const FromServerToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      snakes_game_(from.snakes_game_),
      strawberry_(from.strawberry_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&gameover_, &from.gameover_,
    static_cast<size_t>(reinterpret_cast<char*>(&youcanaddapart_) -
    reinterpret_cast<char*>(&gameover_)) + sizeof(youcanaddapart_));
  // @@protoc_insertion_point(copy_constructor:network.FromServerToClient)
}

void FromServerToClient::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FromServerToClient_network_2eprotoc.base);
  ::memset(&gameover_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&youcanaddapart_) -
      reinterpret_cast<char*>(&gameover_)) + sizeof(youcanaddapart_));
}

FromServerToClient::~FromServerToClient() {
  // @@protoc_insertion_point(destructor:network.FromServerToClient)
  SharedDtor();
}

void FromServerToClient::SharedDtor() {
}

void FromServerToClient::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FromServerToClient& FromServerToClient::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FromServerToClient_network_2eprotoc.base);
  return *internal_default_instance();
}


void FromServerToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:network.FromServerToClient)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  snakes_game_.Clear();
  strawberry_.Clear();
  ::memset(&gameover_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&youcanaddapart_) -
      reinterpret_cast<char*>(&gameover_)) + sizeof(youcanaddapart_));
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FromServerToClient::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool gameover = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_gameover(&has_bits);
          gameover_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool youCanAddAPart = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_youcanaddapart(&has_bits);
          youcanaddapart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .network.Snake snakes_game = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_snakes_game(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .network.StrawBerry strawberry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_strawberry(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FromServerToClient::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FromServerToClient)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool gameover = 1 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_gameover(), target);
  }

  // required bool youCanAddAPart = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_youcanaddapart(), target);
  }

  // repeated .network.Snake snakes_game = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_snakes_game_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_snakes_game(i), target, stream);
  }

  // repeated .network.StrawBerry strawberry = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_strawberry_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_strawberry(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FromServerToClient)
  return target;
}

size_t FromServerToClient::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:network.FromServerToClient)
  size_t total_size = 0;

  if (_internal_has_gameover()) {
    // required bool gameover = 1 [default = false];
    total_size += 1 + 1;
  }

  if (_internal_has_youcanaddapart()) {
    // required bool youCanAddAPart = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t FromServerToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.FromServerToClient)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bool gameover = 1 [default = false];
    total_size += 1 + 1;

    // required bool youCanAddAPart = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .network.Snake snakes_game = 3;
  total_size += 1UL * this->_internal_snakes_game_size();
  for (const auto& msg : this->snakes_game_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .network.StrawBerry strawberry = 4;
  total_size += 1UL * this->_internal_strawberry_size();
  for (const auto& msg : this->strawberry_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FromServerToClient::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.FromServerToClient)
  GOOGLE_DCHECK_NE(&from, this);
  const FromServerToClient* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FromServerToClient>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.FromServerToClient)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.FromServerToClient)
    MergeFrom(*source);
  }
}

void FromServerToClient::MergeFrom(const FromServerToClient& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.FromServerToClient)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  snakes_game_.MergeFrom(from.snakes_game_);
  strawberry_.MergeFrom(from.strawberry_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameover_ = from.gameover_;
    }
    if (cached_has_bits & 0x00000002u) {
      youcanaddapart_ = from.youcanaddapart_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FromServerToClient::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.FromServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FromServerToClient::CopyFrom(const FromServerToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.FromServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FromServerToClient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(snakes_game_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(strawberry_)) return false;
  return true;
}

void FromServerToClient::InternalSwap(FromServerToClient* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  snakes_game_.InternalSwap(&other->snakes_game_);
  strawberry_.InternalSwap(&other->strawberry_);
  swap(gameover_, other->gameover_);
  swap(youcanaddapart_, other->youcanaddapart_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FromServerToClient::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FromClientToServer::InitAsDefaultInstance() {
  ::network::_FromClientToServer_default_instance_._instance.get_mutable()->snakeclient_ = const_cast< ::network::Snake*>(
      ::network::Snake::internal_default_instance());
}
class FromClientToServer::_Internal {
 public:
  using HasBits = decltype(std::declval<FromClientToServer>()._has_bits_);
  static const ::network::Snake& snakeclient(const FromClientToServer* msg);
  static void set_has_snakeclient(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hitwith(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::network::Snake&
FromClientToServer::_Internal::snakeclient(const FromClientToServer* msg) {
  return *msg->snakeclient_;
}
FromClientToServer::FromClientToServer()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FromClientToServer)
}
FromClientToServer::FromClientToServer(const FromClientToServer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_snakeclient()) {
    snakeclient_ = new ::network::Snake(*from.snakeclient_);
  } else {
    snakeclient_ = nullptr;
  }
  hitwith_ = from.hitwith_;
  // @@protoc_insertion_point(copy_constructor:network.FromClientToServer)
}

void FromClientToServer::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FromClientToServer_network_2eprotoc.base);
  ::memset(&snakeclient_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hitwith_) -
      reinterpret_cast<char*>(&snakeclient_)) + sizeof(hitwith_));
}

FromClientToServer::~FromClientToServer() {
  // @@protoc_insertion_point(destructor:network.FromClientToServer)
  SharedDtor();
}

void FromClientToServer::SharedDtor() {
  if (this != internal_default_instance()) delete snakeclient_;
}

void FromClientToServer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FromClientToServer& FromClientToServer::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FromClientToServer_network_2eprotoc.base);
  return *internal_default_instance();
}


void FromClientToServer::Clear() {
// @@protoc_insertion_point(message_clear_start:network.FromClientToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(snakeclient_ != nullptr);
    snakeclient_->Clear();
  }
  hitwith_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FromClientToServer::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .network.Snake snakeclient = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_snakeclient(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .network.FromClientToServer.TypesOfHit hitwith = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::network::FromClientToServer_TypesOfHit_IsValid(val))) {
            _internal_set_hitwith(static_cast<::network::FromClientToServer_TypesOfHit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FromClientToServer::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FromClientToServer)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .network.Snake snakeclient = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::snakeclient(this), target, stream);
  }

  // required .network.FromClientToServer.TypesOfHit hitwith = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_hitwith(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FromClientToServer)
  return target;
}

size_t FromClientToServer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:network.FromClientToServer)
  size_t total_size = 0;

  if (_internal_has_snakeclient()) {
    // required .network.Snake snakeclient = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *snakeclient_);
  }

  if (_internal_has_hitwith()) {
    // required .network.FromClientToServer.TypesOfHit hitwith = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hitwith());
  }

  return total_size;
}
size_t FromClientToServer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.FromClientToServer)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .network.Snake snakeclient = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *snakeclient_);

    // required .network.FromClientToServer.TypesOfHit hitwith = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hitwith());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FromClientToServer::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.FromClientToServer)
  GOOGLE_DCHECK_NE(&from, this);
  const FromClientToServer* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FromClientToServer>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.FromClientToServer)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.FromClientToServer)
    MergeFrom(*source);
  }
}

void FromClientToServer::MergeFrom(const FromClientToServer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.FromClientToServer)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_snakeclient()->::network::Snake::MergeFrom(from._internal_snakeclient());
    }
    if (cached_has_bits & 0x00000002u) {
      hitwith_ = from.hitwith_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FromClientToServer::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.FromClientToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FromClientToServer::CopyFrom(const FromClientToServer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.FromClientToServer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FromClientToServer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (_internal_has_snakeclient()) {
    if (!snakeclient_->IsInitialized()) return false;
  }
  return true;
}

void FromClientToServer::InternalSwap(FromClientToServer* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(snakeclient_, other->snakeclient_);
  swap(hitwith_, other->hitwith_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FromClientToServer::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FirstMessageFromServerToClient::InitAsDefaultInstance() {
  ::network::_FirstMessageFromServerToClient_default_instance_._instance.get_mutable()->walls_ = const_cast< ::network::PositionSnakePart*>(
      ::network::PositionSnakePart::internal_default_instance());
}
class FirstMessageFromServerToClient::_Internal {
 public:
  using HasBits = decltype(std::declval<FirstMessageFromServerToClient>()._has_bits_);
  static const ::network::PositionSnakePart& walls(const FirstMessageFromServerToClient* msg);
  static void set_has_walls(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_idtogive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_you_are(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::network::PositionSnakePart&
FirstMessageFromServerToClient::_Internal::walls(const FirstMessageFromServerToClient* msg) {
  return *msg->walls_;
}
FirstMessageFromServerToClient::FirstMessageFromServerToClient()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:network.FirstMessageFromServerToClient)
}
FirstMessageFromServerToClient::FirstMessageFromServerToClient(const FirstMessageFromServerToClient& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_walls()) {
    walls_ = new ::network::PositionSnakePart(*from.walls_);
  } else {
    walls_ = nullptr;
  }
  ::memcpy(&color_, &from.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&you_are_) -
    reinterpret_cast<char*>(&color_)) + sizeof(you_are_));
  // @@protoc_insertion_point(copy_constructor:network.FirstMessageFromServerToClient)
}

void FirstMessageFromServerToClient::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FirstMessageFromServerToClient_network_2eprotoc.base);
  ::memset(&walls_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&you_are_) -
      reinterpret_cast<char*>(&walls_)) + sizeof(you_are_));
}

FirstMessageFromServerToClient::~FirstMessageFromServerToClient() {
  // @@protoc_insertion_point(destructor:network.FirstMessageFromServerToClient)
  SharedDtor();
}

void FirstMessageFromServerToClient::SharedDtor() {
  if (this != internal_default_instance()) delete walls_;
}

void FirstMessageFromServerToClient::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FirstMessageFromServerToClient& FirstMessageFromServerToClient::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FirstMessageFromServerToClient_network_2eprotoc.base);
  return *internal_default_instance();
}


void FirstMessageFromServerToClient::Clear() {
// @@protoc_insertion_point(message_clear_start:network.FirstMessageFromServerToClient)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(walls_ != nullptr);
    walls_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&you_are_) -
        reinterpret_cast<char*>(&color_)) + sizeof(you_are_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

const char* FirstMessageFromServerToClient::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .network.PositionSnakePart walls = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_walls(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .network.Snake.RGBColor color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::network::Snake_RGBColor_IsValid(val))) {
            _internal_set_color(static_cast<::network::Snake_RGBColor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional int32 idtogive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_idtogive(&has_bits);
          idtogive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::network::FirstMessageFromServerToClient_eYouAre_IsValid(val))) {
            _internal_set_you_are(static_cast<::network::FirstMessageFromServerToClient_eYouAre>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FirstMessageFromServerToClient::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:network.FirstMessageFromServerToClient)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .network.PositionSnakePart walls = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::walls(this), target, stream);
  }

  // optional .network.Snake.RGBColor color = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_color(), target);
  }

  // optional int32 idtogive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_idtogive(), target);
  }

  // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_you_are(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:network.FirstMessageFromServerToClient)
  return target;
}

size_t FirstMessageFromServerToClient::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:network.FirstMessageFromServerToClient)
  size_t total_size = 0;

  // required .network.FirstMessageFromServerToClient.eYouAre you_are = 4;
  if (_internal_has_you_are()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_you_are());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .network.PositionSnakePart walls = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *walls_);
    }

    // optional .network.Snake.RGBColor color = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_color());
    }

    // optional int32 idtogive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_idtogive());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FirstMessageFromServerToClient::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:network.FirstMessageFromServerToClient)
  GOOGLE_DCHECK_NE(&from, this);
  const FirstMessageFromServerToClient* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FirstMessageFromServerToClient>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:network.FirstMessageFromServerToClient)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:network.FirstMessageFromServerToClient)
    MergeFrom(*source);
  }
}

void FirstMessageFromServerToClient::MergeFrom(const FirstMessageFromServerToClient& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:network.FirstMessageFromServerToClient)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_walls()->::network::PositionSnakePart::MergeFrom(from._internal_walls());
    }
    if (cached_has_bits & 0x00000002u) {
      color_ = from.color_;
    }
    if (cached_has_bits & 0x00000004u) {
      idtogive_ = from.idtogive_;
    }
    if (cached_has_bits & 0x00000008u) {
      you_are_ = from.you_are_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FirstMessageFromServerToClient::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:network.FirstMessageFromServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FirstMessageFromServerToClient::CopyFrom(const FirstMessageFromServerToClient& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:network.FirstMessageFromServerToClient)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FirstMessageFromServerToClient::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000008) != 0x00000008) return false;
  if (_internal_has_walls()) {
    if (!walls_->IsInitialized()) return false;
  }
  return true;
}

void FirstMessageFromServerToClient::InternalSwap(FirstMessageFromServerToClient* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(walls_, other->walls_);
  swap(color_, other->color_);
  swap(idtogive_, other->idtogive_);
  swap(you_are_, other->you_are_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FirstMessageFromServerToClient::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace network
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::network::PositionSnakePart* Arena::CreateMaybeMessage< ::network::PositionSnakePart >(Arena* arena) {
  return Arena::CreateInternal< ::network::PositionSnakePart >(arena);
}
template<> PROTOBUF_NOINLINE ::network::StrawBerry* Arena::CreateMaybeMessage< ::network::StrawBerry >(Arena* arena) {
  return Arena::CreateInternal< ::network::StrawBerry >(arena);
}
template<> PROTOBUF_NOINLINE ::network::Snake* Arena::CreateMaybeMessage< ::network::Snake >(Arena* arena) {
  return Arena::CreateInternal< ::network::Snake >(arena);
}
template<> PROTOBUF_NOINLINE ::network::FromServerToClient* Arena::CreateMaybeMessage< ::network::FromServerToClient >(Arena* arena) {
  return Arena::CreateInternal< ::network::FromServerToClient >(arena);
}
template<> PROTOBUF_NOINLINE ::network::FromClientToServer* Arena::CreateMaybeMessage< ::network::FromClientToServer >(Arena* arena) {
  return Arena::CreateInternal< ::network::FromClientToServer >(arena);
}
template<> PROTOBUF_NOINLINE ::network::FirstMessageFromServerToClient* Arena::CreateMaybeMessage< ::network::FirstMessageFromServerToClient >(Arena* arena) {
  return Arena::CreateInternal< ::network::FirstMessageFromServerToClient >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
